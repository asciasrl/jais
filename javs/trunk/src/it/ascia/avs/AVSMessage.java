package it.ascia.avs;

import java.util.EnumSet;

import it.ascia.ais.AISException;
import it.ascia.ais.Message;

public class AVSMessage extends Message {

	private static int CCITT_CRC_POLY = 0x1021;
	
	static int SYNC=0x36;	
		
	enum Code {
		/**
		 * Comunicazione stato da centrale ad host
		 */
		GET_STATO_ZONE_DIG(1,1), 
		GET_TAMPER_ZONE(1,2),
		GET_BYPASS_ZONE(1,3), 
		GET_ANOMALIA_ZONE_RADIO(1,4),
		GET_STATO_SETT(1,5),
		GET_USCITA_OC_DIG(1,6),
		GET_USCITA_RELE(1,7),
		GET_USCITA_SIRENE(1,8),
		GET_USCITA_TAMPER(1,9),
		GET_STATO_ZONE_AN(1,10),
		GET_USCITA_OC_AN(1,12),
		GET_STATO_TAMPER(1,11),
		GET_STATO_USER(1,13),
		GET_LOGIN(1,20),
		
		/**
		 * Modifica stato da host a centrale
		 */
		 // era 2: errore di Presti o di Lissandrini ?
		SET_BYPASS_ZONE(1,3,true),
		SET_STATO_SETT(1,5,true),
		SET_LOGIN(1,20,true),
		
		/**
		 * Comunicazione errori da centrale ad host
		 */
		GET_ERROR(3,-1),
		GET_ERROR_BYPASS_ZONE(3,3),
		GET_ERROR_STATO_SETT(3,5),
		GET_ERROR_USCITA_OC_DIG(3,6),
		GET_ERROR_USCITA_OC_AN(3,12),
		GET_ERROR_LOGIN(3,20),
		GET_ERROR_GENERIC(3,21),
		
		/**
		 * Richiesta informazioni da host a centrale
		 * (non implementato)
		 */
		//ASK_INFO(5),

		/**
		 * Richiesta stato da host a centrale
		 */
		ASK_STATO_ZONE_DIG(6,1,true),
		ASK_STATO_BYPASS_ZONE(6,3,true),
		
		/**
		 * Polling da centrale ad host
		 */
		GET_IDLE(7,0),
		GET_PROT_VERS(7,1),
		
		/**
		 * Riscontro da host a centrale
		 */
		SET_IDLE(7,0, true),
		SET_PROT_VERS(7,1, true);
		

		private int command;
		private int selector;
		private boolean host;
				
		Code(int command, int selector) {
			this(command,selector,false);
		}

		Code(int command, int selector, boolean host) {
			this.command = command;
			this.selector = selector;
			this.host = host;
		}
		
		public int getCommand() {
			return command;
		}
		
		public int getSelector() {
			return selector;
		}

		private boolean getHost() {
			return host;
		}

		/**
		 * Match if command and host are equal
		 * don't care of selector if supplied selector is < 0
		 * @param command
		 * @param selector
		 * @param host
		 * @return
		 */
		public boolean match(int command, int selector, boolean host) {
			if (selector < 0) {
				return match(command, host);
			} else {
				return this.command == command && this.selector == selector && this.host == host;
			}
		}

		/**
		 * Match if command is equal (don't care of selector), assume not host message
		 * @param command
		 * @return
		 */
		public boolean match(int command) {
			return match (command,false);
		}

		/**
		 * Match if command and host are equal (don't care of selector)
		 * @param command
		 * @param host
		 * @return
		 */
		public boolean match(int command, boolean host) {
			return this.command == command && this.host == host;
		}
		
		public boolean match(Code arg) {
			return match(arg.getCommand(),arg.getSelector(),arg.getHost());
		}

		

		/**
		 * Search for a code, assuming message is generated by the interface
		 * @param command
		 * @param selector
		 * @return
		 */
		public static Code get(int command, int selector) {
			return get(command,selector,false);
		}
		
		/**
		 * Search for a code that match given command and selector
		 * @param command
		 * @param selector
		 * @param host True if message is generated by the host
		 * @return
		 */
		public static Code get(int command, int selector, boolean host) {
			if (selector < 0) {
				for (Code code : values()) {
					if (code.match(command,host)) {
						return code;
					}
				}
			} else {
				for (Code code : values()) {
					if (code.match(command,selector,host)) {
						return code;
					}
				}				
			}
			throw(new AISException("Unknow code: "+command+"/"+selector+"/"+host));
		}
	}
	
	/*
	static final String[] commands = {null,"GET_STATO","SET_STATO","GET_ERROR",null,null,"ASK_STATO","GET_INFO"}; 

	*/
	
	static final int SEL_STATO_ZONE_DIG = 1;
	static final int SEL_TAMPER_ZONE = 2;
	static final int SEL_BYPASS_ZONE = 3;
	static final int SEL_ANOMALIA_ZONE_RADIO = 4; // non implementato ?
	static final int SEL_STATO_SETT = 5;
	static final int SEL_USCITA_OC_DIG = 6;
	static final int SEL_USCITA_RELE = 7;
	static final int SEL_USCITA_SIRENE = 8;
	static final int SEL_USCITA_TAMPER = 9;
	static final int SEL_STATO_ZONE_AN = 10;
	static final int SEL_STATO_TAMPER = 11;  // non implementato ?
	static final int SEL_USCITA_OC_AN = 12;
	static final int SEL_STATO_USER = 13;  // non implementato ?
	static final int SEL_LOGIN = 20;
	static final int SEL_GROUP = 21; // non implementato ?
	static final int SEL_GENERIC = 21;
	/*
	static final String[] selectors_stato = {null,"SEL_STATO_ZONE_DIG","SEL_TAMPER_ZONE","SEL_BYPASS_ZONE","SEL_ANOMALIA_ZONE_RADIO","SEL_STATO_SETT","SEL_USCITA_OC_DIG","SEL_USCITA_RELE","SEL_USCITA_SIRENE","SEL_USCITA_TAMPER",
				"SEL_STATO_ZONE_AN",null,"SEL_USCITA_OC_AN",null,null,null,null,null,null,null,
				"SEL_LOGIN","SEL_GENERIC"};	

	static final int SEL_STATO_SPENTO = 0x00;
	static final int SEL_STATO_ACCESO = 0x01;
	static final int SEL_STATO_ACCESO_HOME = 0x02;
	static final int SEL_STATO_ACCESO_AREA = 0x03;
	static final int SEL_STATO_ACCESO_PERIMETER = 0x04;

	static final int SEL_IDLE  = 0x00;
	public static final int SEL_PROT_VERS = 0x01;
	
	static final String[] selectors_info = {"SEL_IDLE","SEL_PROT_VERS"};
	
	static final String[][] selectors = {null,selectors_stato, selectors_stato, selectors_stato, null, null, selectors_stato, selectors_info};
	*/

	static final int ERRORCODE_SELSTATO_UTENTE_NON_ABILIT = 0x80;
	static final int ERRORCODE_SELSTATO_ACCENSIONE_FORZATA = 0x81;
	static final int ERRORCODE_SELSTATO_ERR_AUTOTEST = 0x82;
	static final int ERRORCODE_SELSTATO_PROGR_ORARIO_ATTIVO = 0x83;

	static final int ERRORCODE_SEL_LOGIN_ERR_VALIDAZ = 0x80;
	static final int ERRORCODE_SEL_LOGIN_CADUTA_CONN_OVERFLOW = 0x81;
	/**
	 * caduta connessione per mancata risposta host
	 */
	static final int ERRORCODE_SEL_LOGIN_CADUTA_CONN_MANCATA_RISP = 0x82;
	/**
	 * Caduta connessione per errore handshake (DTR)
	 */
	static final int ERRORCODE_SEL_LOGIN_CADUTA_CONN_ERR_HNDS = 0x83;
	static final int ERRORCODE_SEL_LOGIN_CADUTA_CONN_PROT_NON_DEF = 0x84;

	/**
	 * busy (sistema impegnato)
	 */
	static final int ERRORCODE_SEL_GENERIC_BUSY = 0x90;
	/**
	 * overflow (coda verso host piena)
	 */
	static final int ERRORCODE_SEL_GENERIC_OVERFLOW = 0x91;

	//static final int ERROR_DISPLAY_TIMEOUT = 500;                                          
	
	static final int FORMAT_0 = 0;   //formato speciale
	static final int FORMAT_1 = 1;   //elenco differ.  istanza/valore
	static final int FORMAT_2 = 2;   //elenco completo valori a partire dalla prima istanza 
	static final int FORMAT_3 = 3;   //elenco completo ist/val, con azzeramento istanze non elencate
	static final int FORMAT_4 = 4;   //elenco completo a partire dalla prima istanza (bitmap pack)
	static final int FORMAT_5 = 5;   //elenco completo istanze aperte
	static final int FORMAT_6 = 6;   //elenco diff. istanze chiuse
	static final int FORMAT_7 = 7;   //elenco diff. istanze aperte/chiuse
	static final int FORMAT_8 = 8;   //elenco diff. istanze aperte
	
	
	private int seqNumber;
	private int format;
	
	protected int[] data;

	private Code code;

	public AVSMessage(int seqNumber, Code code, int format, int[] data) {
		if (code == null) {
			throw(new AISException("Code cannot be null"));
		}
		this.seqNumber = seqNumber;
		this.code = code;
		this.format = format;
		this.data = data;
	}

	public AVSMessage(Code code, int format) {
		this(0, code, format, new int[0]);
	}

	public AVSMessage(Code code, int format, int[] data) {
		this(0, code, format, data);
	}

	/**
	 * Must be called by the Connector before getBytesMessage()
	 * @param seqNumber
	 */
	public void setSeqNumber(int seqNumber) {
		this.seqNumber = seqNumber;
	}

	/**
	<pre>
	AVS Electronics S.p.A. - Giugno 2006
	Esempi di implementazione di CRC16 (CCITT) utilizzato nel protocollo EL
	
	Sono riportate tre implementazioni di CRC16
	calc_avs_ccitt_CRC: esegue il calcolo senza utilizzo di tabelle esterne. Occupa meno spazio
	(codice+dati statici) ma richiede piu' risorse di CPU
	CRCCCITTa, CRCCCITTb: equivalenti tra loro, eseguono il calcolo con supporto di una tabelle esterna.
	Occupa piu' spazio (codice+dati statici) ma richiede meno risorse di CPU
	
	Le tre implementazioni danno risultati identici.
	Il polinomio utilizzato e' 0x1021 (g(x) = x16 + x12 + x5 + 1)
	Il valore CRC iniziale e' 0xFFFF. Rispetto al piu' classico 0, questo valore consente di
	differenziare il crc anche se i primi bytes sono nulli.
	
	Per garantire portabilita' in ambienti diversi, si evidenzia che le variabili "unsigned short" sono
	interi a 16 bit senza segno.
	
	------------------------------ implementazione 1: calcolo del CRC bit per bit
	1) CRC iniziale: 0xFFFF
	2) if the CRC left-most bit is equal to 1, shift in the next message bit, and XOR the CRC
	register with the generator polynomial; otherwise, only shift in the next message bit
	3) Repeat step 2 until all bits of the augmented message have been shifted in
	|b15..............b0| |b7.................b0|
	 <------ CRC ------>   <---- input bits---->
	</pre>
	*/
	public static int calcCRC(int CRC, int d) {		
		for (int i=0; i < 8; i++) {
			if ((CRC & 0x8000) == 0x8000) { 
				CRC = (CRC << 1) & 0xFFFF;  //shift in the next message bit
				if ((d & 0x80) == 0x80)
					CRC = (CRC | 0x0001) & 0xFFFF;
				d = (d << 1) & 0xFFFF;
				 //if the CRC left-most bit is equal to 1 XOR the CRC register with the generator polynomial
				CRC = CRC ^ CCITT_CRC_POLY;
			} else {
				CRC = (CRC << 1) & 0xFFFF;  //shift in the next message bit
				if ((d & 0x80) == 0x80)
					CRC = (CRC | 0x0001) & 0xFFFF;
				
				d = (d << 1) & 0xFFFF;				
			}
		}
		return CRC;
	}

	/**
	static int updateCRC(int crc, int b) {
		return updateCRC(crc,b,CCITT_CRC_POLY);
	}
	
	static int updateCRC(int crc, int b, int polynomial) {
		 for (int i = 0; i < 8; i++) {
             boolean bit = ((b   >> (7-i) & 1) == 1);
             boolean c15 = ((crc >> 15    & 1) == 1);
             crc <<= 1;
             if (c15 ^ bit) crc ^= polynomial;
         }
		 return crc & 0xFFFF;
	}
	**/
	
	@Override
	public byte[] getBytesMessage() {
		int l = data.length + 7 + 2;
		int message[] = new int[l];
		
		message[0] = l - 1;		
		message[1] = SYNC;		
		message[2] = seqNumber;
		message[3] = getCommand();
		message[4] = 0x00;
		message[5] = getSelector();
		message[6] = format;
		
		for (int i = 0; i < data.length; i++) {
			message[i + 7] = data[i];
		}
		
		int CRC = 0xFFFF;
		for (int i = 0; i < message.length - 2; i++) {
			CRC = calcCRC(CRC, message[i]);
		}

		message[l - 2] = (CRC & 0xFF00) >>> 8;		
		message[l - 1] = (CRC & 0x00FF);
			
		byte[] bytesMessage = new byte[message.length];
		for (int i = 0; i < message.length; i++) {
			bytesMessage[i] = (new Integer(message[i])).byteValue();
		}
		return bytesMessage;
	}

	@Override
	public String toString() {
		String s = getMessageDescription() 
			+ " Sequence="+((seqNumber >> 4) & 0x0F) + "/" + (seqNumber & 0x0F)  
			//+ " Command="+command+","+commands[command]
			//+ " Selector="+getSelector()+","+selectors[command][getSelector()]
			+ " Code=" + code
            + " Format=" + format;
		if (data.length > 0) {
			s += " Data="+data.length;			
			for (int i=0; i < data.length; i++) {
				s += " " + b2h(data[i]);
			}		
		}
		return s;
	}

	/**
	 * @return the command
	 */
	public int getCommand() {
		return code.getCommand();
	}

	/**
	 * @return the selector
	 */
	public int getSelector() {
		return code.getSelector();
	}
	
	public Code getCode() {
		return code;
	}

	/**
	 * @return the data
	 */
	public int[] getData() {
		return data;
	}

	public String dump() {
		StringBuffer sb = new StringBuffer();
		byte[] m = getBytesMessage(); 
		sb.append(m.length + " bytes:");
		for (int i = 0; i < m.length; i++) {
			sb.append(" "+Message.b2h(m[i]));
		}
		return sb.toString();
	}

}
